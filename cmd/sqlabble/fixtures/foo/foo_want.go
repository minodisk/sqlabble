// Code generated by sqlabble, DO NOT EDIT.
package foo

import (
	"database/sql"
	"strings"

	"github.com/sqlabble/sqlabble"
	"github.com/sqlabble/sqlabble/stmt"
)

// UserDB User table
type UserDB struct {
	Table             stmt.Table
	TableAlias        stmt.TableAlias
	UserIDColumn      stmt.Column
	UserIDColumnAlias stmt.ColumnAlias
	NameColumn        stmt.Column
	NameColumnAlias   stmt.ColumnAlias
	AvatarColumn      stmt.Column
	AvatarColumnAlias stmt.ColumnAlias
	Prof              ProfileDB
}

// NewUserDB Create a/an UserDB
func NewUserDB(aliases ...string) UserDB {
	alias := strings.Join(aliases, ".")
	if alias == "" {
		alias = "users"
	}
	return UserDB{
		Table:             stmt.NewTable("users"),
		TableAlias:        stmt.NewTable("users").As(alias),
		UserIDColumn:      stmt.NewTableAlias(alias).Column("user_id"),
		UserIDColumnAlias: stmt.NewTableAlias(alias).Column("user_id").As(strings.Join(append(aliases, "UserID"), ".")),
		NameColumn:        stmt.NewTableAlias(alias).Column("name"),
		NameColumnAlias:   stmt.NewTableAlias(alias).Column("name").As(strings.Join(append(aliases, "Name"), ".")),
		AvatarColumn:      stmt.NewTableAlias(alias).Column("avatar"),
		AvatarColumnAlias: stmt.NewTableAlias(alias).Column("avatar").As(strings.Join(append(aliases, "Avatar"), ".")),
		Prof:              NewProfileDB(append(aliases, "Prof")...),
	}
}

// Register -
func (u UserDB) Register(mapper map[string]interface{}, dist *User, aliases ...string) {
	mapper[strings.Join(append(aliases, "UserID"), ".")] = &dist.UserID
	mapper[strings.Join(append(aliases, "Name"), ".")] = &dist.Name
	mapper[strings.Join(append(aliases, "Avatar"), ".")] = &dist.Avatar
	u.Prof.Register(mapper, &dist.Prof, append(aliases, "Prof")...)
	mapper[strings.Join(append(aliases, "NumFriends"), ".")] = &dist.NumFriends
}

// Columns -
func (u UserDB) Columns() []stmt.Column {
	return []stmt.Column{
		u.UserIDColumn,
		u.NameColumn,
		u.AvatarColumn,
	}
}

// ColumnAliases -
func (u UserDB) ColumnAliases() []stmt.ColumnAlias {
	aliases := []stmt.ColumnAlias{
		u.UserIDColumnAlias,
		u.NameColumnAlias,
		u.AvatarColumnAlias,
	}
	aliases = append(aliases, u.Prof.ColumnAliases()...)
	return aliases
}

// Selectors -
func (u UserDB) Selectors() []stmt.ValOrColOrAliasOrFuncOrSubOrFormula {
	as := u.ColumnAliases()
	is := make([]stmt.ValOrColOrAliasOrFuncOrSubOrFormula, len(as))
	for i, a := range as {
		is[i] = a
	}
	return is
}

// Map -
func (u UserDB) Map(rows *sql.Rows) ([]User, error) {
	cols, err := rows.Columns()
	if err != nil {
		return nil, err
	}
	dist := []User{}
	for rows.Next() {
		mapper := make(map[string]interface{})
		di := User{}
		u.Register(mapper, &di)
		refs := make([]interface{}, len(cols))
		for i, c := range cols {
			refs[i] = mapper[c]
		}
		if err := rows.Scan(refs...); err != nil {
			return nil, err
		}
		dist = append(dist, di)
	}
	return dist, nil
}

// QueryOne Select single record
func (u UserDB) QueryOne(sess *sqlabble.Session, st stmt.Statement) (User, error) {
	query, values := sess.Builder.Build(st)
	rows, err := sess.Query(query, values...)
	if err != nil {
		return User{}, err
	}
	ms, err := u.Map(rows)
	if err != nil {
		return User{}, err
	}
	if len(ms) == 0 {
		return User{}, sqlabble.NewErrRecordNotFound(u.Table.Name)
	}
	if len(ms) > 1 {
		return User{}, sqlabble.NewErrFoundMultipleRecords(u.Table.Name)
	}
	return ms[0], nil
}

// Count count records
func (u UserDB) Count(sess *sqlabble.Session, op stmt.ComparisonOrLogicalOperation) (int64, error) {
	var query string
	var values []interface{}

	fc := sqlabble.Select(sqlabble.Count(sqlabble.Wildcard)).From(u.Table)
	if op != nil {
		query, values = sess.Builder.Build(fc.Where(op))
	} else {
		query, values = sess.Builder.Build(fc)
	}
	rows, err := sess.Query(query, values...)
	if err != nil {
		return 0, err
	}

	var count int64
	for rows.Next() {
		err := rows.Scan(&count)
		if err != nil {
			return 0, err
		}
	}

	return count, nil
}

// Query select some records
func (u UserDB) Query(sess *sqlabble.Session, st stmt.Statement) ([]User, error) {
	query, values := sess.Builder.Build(st)
	rows, err := sess.Query(query, values...)
	if err != nil {
		return []User{}, err
	}
	ms, err := u.Map(rows)
	if err != nil {
		return []User{}, err
	}

	return ms, nil
}

// Exec execute a query
func (u UserDB) Exec(sess *sqlabble.Session, st stmt.Statement) (sql.Result, error) {
	query, values := sess.Builder.Build(st)
	result, err := sess.Exec(query, values...)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// ProfileDB Profile table
type ProfileDB struct {
	Table                stmt.Table
	TableAlias           stmt.TableAlias
	ProfileIDColumn      stmt.Column
	ProfileIDColumnAlias stmt.ColumnAlias
	BodyColumn           stmt.Column
	BodyColumnAlias      stmt.ColumnAlias
	UserIDColumn         stmt.Column
	UserIDColumnAlias    stmt.ColumnAlias
}

// NewProfileDB Create a/an ProfileDB
func NewProfileDB(aliases ...string) ProfileDB {
	alias := strings.Join(aliases, ".")
	if alias == "" {
		alias = "profiles"
	}
	return ProfileDB{
		Table:                stmt.NewTable("profiles"),
		TableAlias:           stmt.NewTable("profiles").As(alias),
		ProfileIDColumn:      stmt.NewTableAlias(alias).Column("profile_id"),
		ProfileIDColumnAlias: stmt.NewTableAlias(alias).Column("profile_id").As(strings.Join(append(aliases, "ProfileID"), ".")),
		BodyColumn:           stmt.NewTableAlias(alias).Column("body"),
		BodyColumnAlias:      stmt.NewTableAlias(alias).Column("body").As(strings.Join(append(aliases, "Body"), ".")),
		UserIDColumn:         stmt.NewTableAlias(alias).Column("user_id"),
		UserIDColumnAlias:    stmt.NewTableAlias(alias).Column("user_id").As(strings.Join(append(aliases, "UserID"), ".")),
	}
}

// Register -
func (p ProfileDB) Register(mapper map[string]interface{}, dist *Profile, aliases ...string) {
	mapper[strings.Join(append(aliases, "ProfileID"), ".")] = &dist.ProfileID
	mapper[strings.Join(append(aliases, "Body"), ".")] = &dist.Body
	mapper[strings.Join(append(aliases, "UserID"), ".")] = &dist.UserID
}

// Columns -
func (p ProfileDB) Columns() []stmt.Column {
	return []stmt.Column{
		p.ProfileIDColumn,
		p.BodyColumn,
		p.UserIDColumn,
	}
}

// ColumnAliases -
func (p ProfileDB) ColumnAliases() []stmt.ColumnAlias {
	aliases := []stmt.ColumnAlias{
		p.ProfileIDColumnAlias,
		p.BodyColumnAlias,
		p.UserIDColumnAlias,
	}
	return aliases
}

// Selectors -
func (p ProfileDB) Selectors() []stmt.ValOrColOrAliasOrFuncOrSubOrFormula {
	as := p.ColumnAliases()
	is := make([]stmt.ValOrColOrAliasOrFuncOrSubOrFormula, len(as))
	for i, a := range as {
		is[i] = a
	}
	return is
}

// Map -
func (p ProfileDB) Map(rows *sql.Rows) ([]Profile, error) {
	cols, err := rows.Columns()
	if err != nil {
		return nil, err
	}
	dist := []Profile{}
	for rows.Next() {
		mapper := make(map[string]interface{})
		di := Profile{}
		p.Register(mapper, &di)
		refs := make([]interface{}, len(cols))
		for i, c := range cols {
			refs[i] = mapper[c]
		}
		if err := rows.Scan(refs...); err != nil {
			return nil, err
		}
		dist = append(dist, di)
	}
	return dist, nil
}

// QueryOne Select single record
func (p ProfileDB) QueryOne(sess *sqlabble.Session, st stmt.Statement) (Profile, error) {
	query, values := sess.Builder.Build(st)
	rows, err := sess.Query(query, values...)
	if err != nil {
		return Profile{}, err
	}
	ms, err := p.Map(rows)
	if err != nil {
		return Profile{}, err
	}
	if len(ms) == 0 {
		return Profile{}, sqlabble.NewErrRecordNotFound(p.Table.Name)
	}
	if len(ms) > 1 {
		return Profile{}, sqlabble.NewErrFoundMultipleRecords(p.Table.Name)
	}
	return ms[0], nil
}

// Count count records
func (p ProfileDB) Count(sess *sqlabble.Session, op stmt.ComparisonOrLogicalOperation) (int64, error) {
	var query string
	var values []interface{}

	fc := sqlabble.Select(sqlabble.Count(sqlabble.Wildcard)).From(p.Table)
	if op != nil {
		query, values = sess.Builder.Build(fc.Where(op))
	} else {
		query, values = sess.Builder.Build(fc)
	}
	rows, err := sess.Query(query, values...)
	if err != nil {
		return 0, err
	}

	var count int64
	for rows.Next() {
		err := rows.Scan(&count)
		if err != nil {
			return 0, err
		}
	}

	return count, nil
}

// Query select some records
func (p ProfileDB) Query(sess *sqlabble.Session, st stmt.Statement) ([]Profile, error) {
	query, values := sess.Builder.Build(st)
	rows, err := sess.Query(query, values...)
	if err != nil {
		return []Profile{}, err
	}
	ms, err := p.Map(rows)
	if err != nil {
		return []Profile{}, err
	}

	return ms, nil
}

// Exec execute a query
func (p ProfileDB) Exec(sess *sqlabble.Session, st stmt.Statement) (sql.Result, error) {
	query, values := sess.Builder.Build(st)
	result, err := sess.Exec(query, values...)
	if err != nil {
		return nil, err
	}
	return result, nil
}

// FriendDB Friend table
type FriendDB struct {
	Table              stmt.Table
	TableAlias         stmt.TableAlias
	UserID1Column      stmt.Column
	UserID1ColumnAlias stmt.ColumnAlias
	UserID2Column      stmt.Column
	UserID2ColumnAlias stmt.ColumnAlias
}

// NewFriendDB Create a/an FriendDB
func NewFriendDB(aliases ...string) FriendDB {
	alias := strings.Join(aliases, ".")
	if alias == "" {
		alias = "friends"
	}
	return FriendDB{
		Table:              stmt.NewTable("friends"),
		TableAlias:         stmt.NewTable("friends").As(alias),
		UserID1Column:      stmt.NewTableAlias(alias).Column("user_id_1"),
		UserID1ColumnAlias: stmt.NewTableAlias(alias).Column("user_id_1").As(strings.Join(append(aliases, "UserID1"), ".")),
		UserID2Column:      stmt.NewTableAlias(alias).Column("user_id_2"),
		UserID2ColumnAlias: stmt.NewTableAlias(alias).Column("user_id_2").As(strings.Join(append(aliases, "UserID2"), ".")),
	}
}

// Register -
func (f FriendDB) Register(mapper map[string]interface{}, dist *Friend, aliases ...string) {
	mapper[strings.Join(append(aliases, "UserID1"), ".")] = &dist.UserID1
	mapper[strings.Join(append(aliases, "UserID2"), ".")] = &dist.UserID2
}

// Columns -
func (f FriendDB) Columns() []stmt.Column {
	return []stmt.Column{
		f.UserID1Column,
		f.UserID2Column,
	}
}

// ColumnAliases -
func (f FriendDB) ColumnAliases() []stmt.ColumnAlias {
	aliases := []stmt.ColumnAlias{
		f.UserID1ColumnAlias,
		f.UserID2ColumnAlias,
	}
	return aliases
}

// Selectors -
func (f FriendDB) Selectors() []stmt.ValOrColOrAliasOrFuncOrSubOrFormula {
	as := f.ColumnAliases()
	is := make([]stmt.ValOrColOrAliasOrFuncOrSubOrFormula, len(as))
	for i, a := range as {
		is[i] = a
	}
	return is
}

// Map -
func (f FriendDB) Map(rows *sql.Rows) ([]Friend, error) {
	cols, err := rows.Columns()
	if err != nil {
		return nil, err
	}
	dist := []Friend{}
	for rows.Next() {
		mapper := make(map[string]interface{})
		di := Friend{}
		f.Register(mapper, &di)
		refs := make([]interface{}, len(cols))
		for i, c := range cols {
			refs[i] = mapper[c]
		}
		if err := rows.Scan(refs...); err != nil {
			return nil, err
		}
		dist = append(dist, di)
	}
	return dist, nil
}

// QueryOne Select single record
func (f FriendDB) QueryOne(sess *sqlabble.Session, st stmt.Statement) (Friend, error) {
	query, values := sess.Builder.Build(st)
	rows, err := sess.Query(query, values...)
	if err != nil {
		return Friend{}, err
	}
	ms, err := f.Map(rows)
	if err != nil {
		return Friend{}, err
	}
	if len(ms) == 0 {
		return Friend{}, sqlabble.NewErrRecordNotFound(f.Table.Name)
	}
	if len(ms) > 1 {
		return Friend{}, sqlabble.NewErrFoundMultipleRecords(f.Table.Name)
	}
	return ms[0], nil
}

// Count count records
func (f FriendDB) Count(sess *sqlabble.Session, op stmt.ComparisonOrLogicalOperation) (int64, error) {
	var query string
	var values []interface{}

	fc := sqlabble.Select(sqlabble.Count(sqlabble.Wildcard)).From(f.Table)
	if op != nil {
		query, values = sess.Builder.Build(fc.Where(op))
	} else {
		query, values = sess.Builder.Build(fc)
	}
	rows, err := sess.Query(query, values...)
	if err != nil {
		return 0, err
	}

	var count int64
	for rows.Next() {
		err := rows.Scan(&count)
		if err != nil {
			return 0, err
		}
	}

	return count, nil
}

// Query select some records
func (f FriendDB) Query(sess *sqlabble.Session, st stmt.Statement) ([]Friend, error) {
	query, values := sess.Builder.Build(st)
	rows, err := sess.Query(query, values...)
	if err != nil {
		return []Friend{}, err
	}
	ms, err := f.Map(rows)
	if err != nil {
		return []Friend{}, err
	}

	return ms, nil
}

// Exec execute a query
func (f FriendDB) Exec(sess *sqlabble.Session, st stmt.Statement) (sql.Result, error) {
	query, values := sess.Builder.Build(st)
	result, err := sess.Exec(query, values...)
	if err != nil {
		return nil, err
	}
	return result, nil
}
